\documentclass{beamer}

\setlength{\leftmargini}{1em}
\setbeamertemplate{itemize item}[circle]
\setbeamertemplate{frametitle}
{
\raggedright\insertframetitle%
}

\usepackage{lipsum}

\usepackage{agda}
\usepackage{apacite}
\usepackage{catchfilebetweentags}
\usepackage{changepage}
\usepackage{babel}
\usepackage{bookmark}

\usepackage{graphicx}

\usepackage[autostyle=true,french=guillemets,maxlevel=3]{csquotes}

\graphicspath{ {images/} }

\usepackage{newunicodechar}
\newunicodechar{∋}{$\ni$}
% \newunicodechar{·}{$\cdot$}
\newunicodechar{⊢}{$\vdash$}
\newunicodechar{⋆}{${}^\star$}
\newunicodechar{Π}{$\Pi$}
\newunicodechar{⇒}{$\Rightarrow$}
\newunicodechar{ƛ}{$\lambdabar$}
\newunicodechar{∅}{$\emptyset$}
\newunicodechar{∀}{$\forall$}
\newunicodechar{ϕ}{$\Phi$}
\newunicodechar{ψ}{$\Psi$}
\newunicodechar{ρ}{$\rho$}
\newunicodechar{α}{$\alpha$}
\newunicodechar{β}{$\beta$}
\newunicodechar{μ}{$\mu$}
\newunicodechar{σ}{$\sigma$}
\newunicodechar{≡}{$\equiv$}
\newunicodechar{Γ}{$\Gamma$}
\newunicodechar{∥}{$\parallel$}
\newunicodechar{Λ}{$\Lambda$}
\newunicodechar{₀}{$~_0$}
\newunicodechar{₁}{$~_1$}
\newunicodechar{₂}{$~_2$}
\newunicodechar{₃}{$~_3$}
\newunicodechar{θ}{$\theta$}
\newunicodechar{Θ}{$\Theta$}
\newunicodechar{∘}{$\circ$}
\newunicodechar{Δ}{$\Delta$}
\newunicodechar{λ}{$\lambda$}
\newunicodechar{⊧}{$\models$}
\newunicodechar{⊎}{$\uplus$}
\newunicodechar{η}{$\eta$}
\newunicodechar{⊥}{$\bot$}
\newunicodechar{Σ}{$\Sigma$}
\newunicodechar{ξ}{$\xi$}
\newunicodechar{ℕ}{$\mathbb{N}$}
\newunicodechar{ᶜ}{${}^c$}
\newunicodechar{Φ}{$\Phi$}
\newunicodechar{Ψ}{$\Psi$}
\newunicodechar{⊤}{$\top$}
\newunicodechar{≐}{$\doteq$}
\newunicodechar{≣}{$\triangleq$}
\newunicodechar{≃}{$\simeq$}
\newunicodechar{≅}{$\cong$}
\newunicodechar{∙}{$\bullet$}
\newunicodechar{ℓ}{$\ell$}
\newunicodechar{ℚ}{$\Q$}
\newunicodechar{ℤ}{$\Z$}
\newunicodechar{⦃}{$\{$}
\newunicodechar{⦄}{$\}$}
\newunicodechar{≤}{$\leqslant$}
\newunicodechar{≥}{$\geqslant$}
\newunicodechar{≟}{$\doteq$}
% \newunicodechar{}{$$}


\newunicodechar{∣}{\ensuremath{\mathnormal{\|}}}
\newunicodechar{∷}{\ensuremath{::}}

\newcommand{\agda}[2]{\ExecuteMetaData[latex/#1.tex]{#2}}

\usetheme{Frankfurt}

\DeclareQuoteStyle{english}
  {\em}
    {\em}
    {\textquotedblleft\em}
    {\em\textquotedblright}

% Information to be included in the title page:
\title{A Simplified version of Bitcoin, \\
    implemented in Agda}
\author[Guilherme]{Guilherme Horta Alvares da Silva}
% \institute{Fundação Getulio Vargas}
\date{2021}


\begin{document}

\frame{\titlepage}

\begin{frame}
\frametitle{Goal}
\begin{itemize}
  \item Program a cryptocurrency (similar to Bitcoin) in Agda, which is dependently typed.
    \includegraphics[width=8cm, height=5cm]{TwoBitcoins}
\end{itemize}
\end{frame}

\begin{frame}
   \frametitle{Definition}
\begin{itemize}
     \item A cryptocurrency is a decentralized means of exchange that uses technology
       blockchain and cryptography to ensure the validity of transactions and the creation of new currency units.
     \item Bitcoin is considered the world's first decentralized digital currency,
       constituting an alternative economic system (\foreignquote{english}{peer-to-peer electronic cash system})
       and responsible for the resurgence of the free banking system.
       \cite{nakamoto2008bitcoin}
     \item Bitcoin allows financial transactions without intermediaries,
       but verified by all users (network nodes).
       These transactions are recorded in a distributed database (a decentralized network),
       called \foreignquote{english}{blockchain}.
     \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Imports}
\begin{code}

module main where

open import Data.Nat
open import Data.List
open import Data.Unit hiding (_≤_; _≟_)
open import Data.Empty
open import Data.Sum hiding (map)
open import Data.Fin hiding (_+_; _≥_; _≤_; _-_; _≟_)
open import Data.Product hiding (map)
open import Function
open import Relation.Binary.PropositionalEquality
open import Relation.Nullary
open import Utils

\end{code}
\end{frame}

\begin{frame}
  \frametitle{Bitcoin Account}
    \includegraphics[width=11cm, height=7cm]{privatekey}
\end{frame}

\begin{frame}
  \frametitle{Hash Function}
  \begin{itemize}
    \item A hash function serves to compress large data into small data.
    \item It is assumed that two different files will always have different hashes (injectivity),
      since the probability of two files having the same hash is negligible.
    \item By the pigeon house principle, the injectivity of the hash is impossible.
      However, two files that have the same hash were never found in SHA-256.
    \item Google found two files that had the same hash in SHA-1.
      Soon after, this hash function stopped being used.
    \item It must also not be possible to compute the inverse of the hash function.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Cryptographic Functions}
  \begin{itemize}
    \item In Bitcoin, there is a private and a public key.
    \item The private key is used to sign the transaction.
    \item The public key, derived from the private key,
      serves to demonstrate that the user is the owner of the private key.
    \item These functions are based on the SHA-256 hash function.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Messages}
\begin{code}

variable
  MsgPrimitive : Set

data Msg : Set₁ where
  msgPrimitive : MsgPrimitive → Msg
  _+msg_ : Msg → Msg → Msg

infixr 5 _+msg_

record HasMsg (A : Set) : Set₁ where
  field
    toMsgPrimitive : A → MsgPrimitive

toMsg : {A : Set} ⦃ _ : HasMsg A ⦄ → A → Msg
toMsg {A} ⦃ record { toMsgPrimitive = toMsgPrimitive } ⦄ x
  = msgPrimitive {A} (toMsgPrimitive x)

open HasMsg

\end{code}
\end{frame}

\begin{frame}
  \frametitle{Crypto Constants}
\begin{code}

module Crypto
  ⦃ _ : HasMsg ℕ ⦄
  (PublicKey : Set)
  (PrivateKey : Set)
  (Address : Set)
  ⦃ _ : HasMsg Address ⦄
  (Signature : Set)
  (Hashed : Set)
  where

  Amount = ℕ
  Time = ℕ
  sucTime : ℕ → ℕ
  sucTime = suc

\end{code}
\end{frame}

\begin{frame}
  \frametitle{Crypto Postulates}
\begin{code}

  record CryptoPostulates : Set₁ where
    field
      _priv≡pub_ : PrivateKey → PublicKey → Set
      publicKey2Address : PublicKey → Address
      Signed : Msg → PublicKey → Signature → Set
      Signed? : (msg : Msg) (pk : PublicKey)
        (sig : Signature) → Dec $ Signed msg pk sig
      hashMsg : Msg → Hashed
      hash-inj : ∀ m n → hashMsg m ≡ hashMsg n
                  → m ≡ n

  module CryptoWithPostulates
    (crypto-postulates : CryptoPostulates)
    where

    open CryptoPostulates crypto-postulates

\end{code}
\end{frame}

\begin{frame}
  \frametitle{Message Signed}
\begin{code}
    record SignedWithSigPbk (msg : Msg)(address : Address)
      : Set where
      field
        publicKey   :  PublicKey
        pbkCorrect  :  publicKey2Address publicKey ≡ address
        signature   :  Signature
        signed      :  Signed msg publicKey signature

\end{code}
\end{frame}

\begin{frame}
   \frametitle{Transactions}
   \begin{itemize}
     \item From transactions, it is possible to send Bitcoins from one account to another.
     \item Transactions are like a check. The individual specifies an amount and signs the transaction.
     \item In Bitcoin transaction, previously unspent transactions must be specified.
       In the case of the miner transaction, this should not be specified.
       Furthermore, it must be specified who should receive the money from these transactions and
       also the transaction must have a signature generated from the private key proving
       that the public key user agreed to make that transaction.
   \end{itemize}
\end{frame}

\begin{frame}
\begin{code}

    record TXField : Set where
      constructor txfield
      field
        amount  : Amount
        address : Address

    record TXFieldWithId : Set where
      constructor txfieldid
      field
        time     : Time
        position : ℕ
        amount   : Amount
        address  : Address

    removeId : TXFieldWithId → TXField
    removeId record { time = time ; position = position
      ; amount = amount ; address = address }
      = record { amount = amount ; address = address }

\end{code}
\end{frame}
% \begin{frame}
\AgdaHide{
\begin{code}

    data VectorOutput : (time : Time) (size : ℕ)
      (amount : Amount) → Set where
      fstEl : ∀ {time : Time}
        (tx : TXFieldWithId)
        (sameId : TXFieldWithId.time tx ≡ time)
        (elStart : TXFieldWithId.position tx ≡ zero)
        → VectorOutput time 1 (TXFieldWithId.amount tx)

      cons : ∀ {time : Time} {size : ℕ} {amount : Amount}
        (listOutput : VectorOutput time size amount)
        (tx : TXFieldWithId)
        (sameId : TXFieldWithId.time tx ≡ time)
        (elStart : TXFieldWithId.position tx ≡ size)
        → VectorOutput time (suc size)
          (amount + TXFieldWithId.amount tx)

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

    VectorOutput→List : ∀ {time : Time} {size : ℕ}
      {amount : Amount}
      (outs : VectorOutput time size amount)
      → List TXFieldWithId
    VectorOutput→List (fstEl tx sameId elStart) = tx ∷ []
    VectorOutput→List (cons outs tx sameId elStart) =
      tx ∷ VectorOutput→List outs

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

    TX→Msg : (tx : TXField) → Msg
    TX→Msg record { amount = amount ; address = address }
      = toMsg amount +msg toMsg address

    TXId→Msg : (tx : TXFieldWithId) → Msg
    TXId→Msg record { time = time ; position = position
      ; amount = amount ; address = address }
      = toMsg time +msg toMsg position +msg
        toMsg amount +msg toMsg address

    txInput→Msg : (input : TXFieldWithId) (outputs : List TXField)
      → NonNil outputs → Msg
    txInput→Msg input [] ()
    txInput→Msg input (output ∷ []) _
      = TX→Msg output +msg TXId→Msg input
    txInput→Msg input (output ∷ out2 ∷ outputs) _
      = TX→Msg output +msg txInput→Msg input
        (out2 ∷ outputs) tt

    txEls→Msg : ∀ {inputs : List TXFieldWithId}
      (input : TXFieldWithId) (outputs : List TXFieldWithId)
      → NonNil inputs × NonNil outputs → Msg
    txEls→Msg input [] (_ , ())
    txEls→Msg input (output ∷ outputs) _
      = txInput→Msg input (map removeId (output ∷ outputs)) tt

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

    txEls→MsgVecOut :
      {time      : Time}
      {outSize   : ℕ}
      {outAmount : Amount}
      (input     : TXFieldWithId)
      (outputs   : VectorOutput time outSize outAmount)
      → Msg
    txEls→MsgVecOut input (fstEl tx sameId elStart)
      = TX→Msg (removeId tx) +msg TXId→Msg input
    txEls→MsgVecOut input (cons outputs tx sameId elStart) =
      TX→Msg (removeId tx) +msg
      txEls→MsgVecOut input outputs

    txFieldList→TotalAmount : (txs : List TXFieldWithId) → Amount
    txFieldList→TotalAmount [] = zero
    txFieldList→TotalAmount (x ∷ txs)
      = txFieldList→TotalAmount txs + amount x
      where open TXFieldWithId

\end{code}
}
% \end{frame}
\begin{frame}
\begin{code}

    record TXSigned
      {time      : Time}
      {outSize   : ℕ}
      {outAmount : Amount}
      (inputs    : List TXFieldWithId)
      (outputs   : VectorOutput time outSize outAmount)
        : Set where
      constructor txsig
      field
        nonEmpty : NonNil inputs
        signed   : All
          (λ input →
          SignedWithSigPbk (txEls→MsgVecOut input outputs)
                          (TXFieldWithId.address input))
                          inputs
        in≥out : txFieldList→TotalAmount inputs ≥ outAmount

\end{code}
\end{frame}
% \begin{frame}
\AgdaHide{
\begin{code}

    record TXSignedRawOutput
      (inputs : List TXFieldWithId)
      (outputs : List TXFieldWithId) : Set where
      field
        nonEmpty : NonNil inputs × NonNil outputs
        signed   : All
          (λ input →
          SignedWithSigPbk (txEls→Msg input outputs nonEmpty)
                          (TXFieldWithId.address input))
                          inputs
        in≥out : txFieldList→TotalAmount inputs
                 ≥ txFieldList→TotalAmount outputs

    txSigInput : {inputs : List TXFieldWithId}
      {outputs : List TXFieldWithId}
      (tx : TXSignedRawOutput inputs outputs)
      → List TXFieldWithId
    txSigInput {inputs} _ = inputs

\end{code}
}
% \end{frame}
\begin{frame}
  \frametitle{Blockchain constants}
\begin{code}

    module WithConstants
      (totalQtSub1 : ℕ)
      (blockReward : ℕ → ℕ)
      where

      totalQt : ℕ
      totalQt = suc totalQtSub1

      tQtTxs : Set
      tQtTxs = Fin $ totalQt

\end{code}
\end{frame}

\begin{frame}
   \frametitle{Unspent Transaction Model}
   \begin{itemize}
     \item In the unspent transaction model, every transaction is added to the transaction tree.
     \item To find out the balance of an account it is necessary to look at all unspent transactions
       sent to that account.
     \item To transact the currency it is necessary to use as input the outputs of
       other unspent transactions.
   \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Bitcoin UTXO}
    \includegraphics[width=11cm, height=7cm]{utxo}
\end{frame}

\begin{frame}
   \frametitle{Transaction Trees}
   \begin{itemize}
     \item The idea of the transaction tree is to gather all transactions into a tree.
     \item In this way, it is possible to synthesize the information of all transactions
       calculating just their hash.
     \item With the injectivity property of the hash, it is possible to verify that two trees
       are equal in constant time complexity.
   \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Transaction tree}
    \includegraphics[width=10cm, height=5cm]{blockchain}
\end{frame}

\begin{frame}
  \frametitle{Transaction tree}
\begin{code}

      mutual
        data TXTree : (time : Time) (block : ℕ)
          (outputs : List TXFieldWithId)
          (totalFees : Amount)
          (qtTransactions : tQtTxs) → Set where

          genesisTree : TXTree zero zero [] zero zero

\end{code}
\end{frame}
\begin{frame}
\begin{code}

          txtree      :
            {block : ℕ} {time : Time}
            {outSize : ℕ} {amount : Amount}
            {inputs : List TXFieldWithId}
            {outputTX : VectorOutput time outSize amount}
            {totalFees : Amount} {qtTransactions : tQtTxs}
            (tree : TXTree time block inputs totalFees qtTransactions)
            (tx : TX {time} {block} {inputs} {outSize} tree outputTX)
            (proofLessQtTX :
                toℕ qtTransactions ≤ totalQtSub1
                ⊎
                (isCoinbase tx))
            → TXTree (sucTime time)
              (nextBlock tx)
              (inputsTX tx ++ VectorOutput→List outputTX)
              (incFees tx) (incQtTx tx proofLessQtTX)

\end{code}
\end{frame}
\begin{frame}
  \frametitle{Transaction}
\begin{code}

        data TX {time : Time} {block : ℕ}
            {inputs : List TXFieldWithId} {outSize : ℕ}
            {outAmount : Amount} {totalFees : ℕ}
            {qtTransactions : tQtTxs}
          : (tr : TXTree time block inputs totalFees qtTransactions)
            (outputs : VectorOutput time outSize outAmount)
            → Set where
          normalTX :
            (tr : TXTree time block inputs totalFees qtTransactions)
            (SubInputs : SubList inputs)
            (outputs : VectorOutput time outSize outAmount)
            (txSigned : TXSigned (sub→list SubInputs) outputs)
            → TX tr outputs

\end{code}
\end{frame}
\begin{frame}
\begin{code}

          coinbase :
            (tr : TXTree time block inputs totalFees qtTransactions)
            (outputs : VectorOutput time outSize outAmount)
            (pAmountFee : outAmount out≡Fee totalFees
              +RewardBlock block)
            → TX tr outputs

\end{code}
\end{frame}
% \begin{frame}
\AgdaHide{
\begin{code}

        isCoinbase : ∀ {block : ℕ} {time : Time}
          {inputs : List TXFieldWithId}
          {outSize : ℕ} {amount : Amount}
          {totalFees : ℕ} {qtTransactions : tQtTxs}
          {tr : TXTree time block inputs totalFees qtTransactions}
          {outputs : VectorOutput time outSize amount}
          (tx : TX {time} {block} {inputs} {outSize} tr outputs)
          → Set
        isCoinbase (normalTX _ _ _ _) = ⊥
        isCoinbase (coinbase _ _ _)     = ⊤

        nextBlock : ∀ {block : ℕ} {time : Time}
          {inputs : List TXFieldWithId}
          {outSize : ℕ} {amount : Amount}
          {totalFees : ℕ} {qtTransactions : tQtTxs}
          {tr : TXTree time block inputs totalFees qtTransactions}
          {outputs : VectorOutput time outSize amount}
          (tx : TX {time} {block} {inputs} {outSize} tr outputs)
          → ℕ

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        nextBlock (normalTX genesisTree _ _ _) = zero
        nextBlock {block} (normalTX (txtree _
          (normalTX _ _ _ _) _) _ _ _) = block
        nextBlock {block} (normalTX (txtree _
          (coinbase _ _ _) _) _ _ _) = suc block
        nextBlock (coinbase genesisTree _ _) = zero
        nextBlock {block} (coinbase (txtree _
          (normalTX _ _ _ _) _) _ _) = block
        nextBlock {block} (coinbase (txtree _
          (coinbase _ _ _) _) _ _) = suc block

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        inputsTX : ∀ {block : ℕ} {time : Time}
          {inputs : List TXFieldWithId}
          {outSize : ℕ} {amount : Amount}
          {totalFees : ℕ} {qtTransactions : tQtTxs}
          {tr : TXTree time block inputs totalFees qtTransactions}
          {outputs : VectorOutput time outSize amount}
          (tx : TX {time} {block} {inputs} {outSize} tr outputs)
          → List TXFieldWithId
        inputsTX (normalTX _ SubInputs _ _) = list-sub SubInputs
        inputsTX {_} {_} {inputs} (coinbase _ _ _) = inputs

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        postulate
          incQtTx : ∀ {qtTransactions : tQtTxs}
            {block : ℕ} {time : Time}
            {inputs : List TXFieldWithId}
            {outSize : ℕ} {amount : Amount}
            {totalFees : ℕ}
            {tr : TXTree time block inputs totalFees qtTransactions}
            {outputs : VectorOutput time outSize amount}
            (tx : TX {time} {block} {inputs} {outSize} tr outputs)
            (proofLessQtTX :
                toℕ qtTransactions ≤ totalQtSub1
                ⊎
                (isCoinbase tx))
            → tQtTxs

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        incFees : ∀ {block : ℕ} {time : Time}
          {inputs : List TXFieldWithId}
          {outSize : ℕ} {amount : Amount}
          {totalFees : Amount} {qtTransactions : tQtTxs}
          {tr : TXTree time block inputs totalFees qtTransactions}
          {outputs : VectorOutput time outSize amount}
          (tx : TX {time} {block} {inputs} {outSize} tr outputs)
          → Amount
        incFees {_} {_} {_} {_} {amount} {totalFees}
          (normalTX _ SubInputs _ (txsig _ _ in≥out)) =
          txFieldList→TotalAmount (sub→list SubInputs)
          - amount p≥ in≥out
          + totalFees
        incFees (coinbase tr outputs _) = zero

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        _out≡Fee_+RewardBlock_ : (amount : Amount)
          (totalFees : Amount)
          (block : ℕ) → Set
        amount out≡Fee totalFees +RewardBlock block =
          amount ≡ totalFees + blockReward block

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}


      data nextTXTree :
        {block₁ : ℕ}
        {time₁ : Time}
        {outputs₁ : List TXFieldWithId}
        {totalFees₁ : Amount}
        {qtTransactions₁ : tQtTxs}
        (txTree₁ : TXTree time₁ block₁ outputs₁
          totalFees₁ qtTransactions₁)

        {block₂ : ℕ}
        {time₂ : Time}
        {outputs₂ : List TXFieldWithId}
        {totalFees₂ : Amount}
        {qtTransactions₂ : tQtTxs}
        (txTree₂ : TXTree time₂ block₂ outputs₂
          totalFees₂ qtTransactions₂)
        → Set where

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        firstTX : ∀ {block time outputs totalFees qtTransactions}
          (txTree : TXTree time block outputs totalFees qtTransactions)
          → nextTXTree txTree txTree
        nextTX : ∀ {block₁ time₁ outputs₁ totalFees₁ qtTransactions₁}
          {txTree₁ : TXTree time₁ block₁
            outputs₁ totalFees₁ qtTransactions₁}

          {block₂ time₂ outputs₂ totalFees₂ qtTransactions₂}
          {txTree₂ : TXTree time₂ block₂
            outputs₂ totalFees₂ qtTransactions₂}

          (nxTree : nextTXTree txTree₁ txTree₂)

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

          {outSize amount}
          {outputTX : VectorOutput time₂ outSize amount}
          (tx : TX txTree₂ outputTX)
          (proofLessQtTX :
              toℕ qtTransactions₂ ≤ totalQtSub1
              ⊎
              (isCoinbase tx))
          → nextTXTree txTree₁ (txtree txTree₂ tx proofLessQtTX)

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      firstTreesInBlock : ∀
        {block time outputs totalFees qtTransactions}
        (tree : TXTree time block outputs totalFees qtTransactions)
        → Set
      firstTreesInBlock genesisTree = ⊤
      firstTreesInBlock (txtree genesisTree _ _) = ⊥
      firstTreesInBlock (txtree (txtree _
        (normalTX _ _ _ _) _) _ _) = ⊥
      firstTreesInBlock (txtree (txtree _
        (coinbase _ _ _) _) _ _) = ⊤

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      isFirstTreeInBlock : ∀
        {block time outputs totalFees qtTransactions}
        (tree : TXTree time block outputs totalFees qtTransactions)
        → Dec (firstTreesInBlock tree)
      isFirstTreeInBlock genesisTree = yes tt
      isFirstTreeInBlock (txtree genesisTree
        (normalTX _ _ _ _) _) = no λ x → x
      isFirstTreeInBlock (txtree genesisTree
        (coinbase _ _ _) _) = no λ x → x
      isFirstTreeInBlock (txtree (txtree _
        (normalTX _ _ _ _) _) _ _) = no λ x → x
      isFirstTreeInBlock (txtree (txtree _
        (coinbase _ _ _) _) _ _) = yes tt

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      coinbaseTree : ∀
        {block time outputs totalFees qtTransactions}
        (tree : TXTree time block outputs totalFees qtTransactions)
        → Set
      coinbaseTree genesisTree = ⊥
      coinbaseTree (txtree _ (normalTX _ _ _ _) _) = ⊥
      coinbaseTree (txtree _ (coinbase _ _ _) _) = ⊤

\end{code}
}
% \end{frame}

\begin{frame}
   \frametitle{Blocks and Blockchain}
   \begin{itemize}
     \item Transactions are embedded in blocks where they are stored.
     \item In Bitcoin, there is a chain of blocks called a blockchain.
       The first block is called genesis block and
       every 10 minutes on average, a new block is added to this blockchain.
     \item There is a limit of transactions that each block can have (in Bitcoin, it's 10 MB of data).
       Therefore, it is important to pay a transaction fee for this transaction to be included in the
       blockchain.
     \item If there are two blockchains on different computers, it is considered
       the valid blockchain the one with the most blocks.
   \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Blockchain}
\includegraphics[width=11cm, height=8cm]{blockchain1}
\end{frame}

\begin{frame}
\frametitle{Blockchain}
\includegraphics[width=11cm, height=8cm]{blockchain2}
\end{frame}

\begin{frame}
  \frametitle{Block}
\begin{code}

      record Block
        {block₁ : ℕ}
        {time₁ : Time}
        {outputs₁ : List TXFieldWithId}
        {totalFees₁ : Amount}
        {qtTransactions₁ : tQtTxs}
        (txTree₁ : TXTree time₁ block₁ outputs₁
          totalFees₁ qtTransactions₁)

        {time₂ : Time}
        {outputs₂ : List TXFieldWithId}
        {totalFees₂ : Amount}
        {qtTransactions₂ : tQtTxs}
        (txTree₂ : TXTree time₂ block₁ outputs₂
          totalFees₂ qtTransactions₂)
        : Set where

\end{code}
\end{frame}
\begin{frame}
  \frametitle{Block}
\begin{code}

        constructor blockc
        field
          nxTree           : nextTXTree txTree₁ txTree₂
          fstBlock         : firstTreesInBlock txTree₁
          sndBlockCoinbase : coinbaseTree txTree₂

\end{code}
\end{frame}
% \begin{frame}
\AgdaHide{
\begin{code}

      fstTree→coinbase : ∀
        {block time outputs totalFees qtTransactions}
        {tree : TXTree time block outputs totalFees qtTransactions}
        {outSize amount}
        {outputTX : VectorOutput time outSize amount}
        {tx : TX tree outputTX}
        {proofLessQtTX :
            toℕ qtTransactions ≤ totalQtSub1
            ⊎
            (isCoinbase tx)}
        (fstTree : firstTreesInBlock (txtree tree tx proofLessQtTX))
        → coinbaseTree tree

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      fstTree→coinbase {_} {_} {_} {_} {_} {genesisTree} ()
      fstTree→coinbase {_} {_} {_} {_} {_}
        {txtree _ (normalTX _ _ _ _) _} ()
      fstTree→coinbase {_} {_} {_} {_} {_}
        {txtree _ (coinbase _ _ _) _} _ = tt

\end{code}
}
% \end{frame}
\begin{frame}
  \frametitle{Blockchain}
\begin{code}

      data Blockchain :
        {block₁ : ℕ}
        {time₁ : Time}
        {outputs₁ : List TXFieldWithId}
        {totalFees₁ : Amount}
        {qtTransactions₁ : tQtTxs}
        {txTree₁ : TXTree time₁ block₁ outputs₁
          totalFees₁ qtTransactions₁}

        {time₂ : Time}
        {outputs₂ : List TXFieldWithId}
        {totalFees₂ : Amount}
        {qtTransactions₂ : tQtTxs}
        {txTree₂ : TXTree time₂ block₁ outputs₂ totalFees₂
          qtTransactions₂}
        (block : Block txTree₁ txTree₂)
        → Set where

\end{code}
\end{frame}
\begin{frame}
  \frametitle{Blockchain}
\begin{code}

          fstBlock' :
            {block₁ : ℕ}
            {time₁ : Time}
            {outputs₁ : List TXFieldWithId}
            {totalFees₁ : Amount}
            {qtTransactions₁ : tQtTxs}
            {txTree₁ : TXTree time₁ block₁ outputs₁ totalFees₁
              qtTransactions₁}

            {time₂ : Time}
            {outputs₂ : List TXFieldWithId}
            {totalFees₂ : Amount}
            {qtTransactions₂ : tQtTxs}
            {txTree₂ : TXTree time₂ block₁ outputs₂ totalFees₂
              qtTransactions₂}
            (block : Block txTree₁ txTree₂)
            → Blockchain block

\end{code}
\end{frame}
\begin{frame}
  \frametitle{Blockchain}
\begin{code}

          addBlock :
            {block-p₁ : ℕ}
            {time-p₁ : Time}
            {outputs-p₁ : List TXFieldWithId}
            {totalFees-p₁ : Amount}
            {qtTransactions-p₁ : tQtTxs}
            {txTree-p₁ : TXTree time-p₁ block-p₁
              outputs-p₁ totalFees-p₁ qtTransactions-p₁}

            {time-p₂ : Time}
            {outputs-p₂ : List TXFieldWithId}
            {totalFees-p₂ : Amount}
            {qtTransactions-p₂ : tQtTxs}
            {txTree-p₂ : TXTree time-p₂ block-p₁
              outputs-p₂ totalFees-p₂ qtTransactions-p₂}
            {block-p : Block txTree-p₁ txTree-p₂}
            (blockchain : Blockchain block-p)

\end{code}
\end{frame}
\begin{frame}
  \frametitle{Blockchain}
\begin{code}

            {outSize : ℕ}
            {amount : Amount}
            {outputTX : VectorOutput time-p₂ outSize amount}
            {tx : TX {time-p₂} {block-p₁}
              {outputs-p₂} {outSize} txTree-p₂ outputTX}
            {proofLessQtTX :
                toℕ qtTransactions-p₂ ≤ totalQtSub1
                ⊎
                (isCoinbase tx)}

            {time₂ : Time}
            {outputs₂ : List TXFieldWithId}
            {totalFees₂ : Amount}
            {qtTransactions₂ : tQtTxs}
            {txTree₂ : TXTree time₂ (nextBlock tx) outputs₂
              totalFees₂ qtTransactions₂}
            (block : Block (txtree txTree-p₂ tx proofLessQtTX)
              txTree₂)
            → Blockchain block

\end{code}
\end{frame}
% \begin{frame}
\AgdaHide{
\begin{code}

      record RawBlock
        {block : ℕ}
        {time₂ : Time}
        {outputs₂ : List TXFieldWithId}
        {totalFees₂ : Amount}
        {qtTransactions₂ : tQtTxs}
        (tree₂ : TXTree time₂ block outputs₂ totalFees₂
          qtTransactions₂)
        : Set where
        constructor rawBlockc

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        field
          {time}           : Time
          {outputs}        : List TXFieldWithId
          {totalFees}      : Amount
          {qtTransactions} : tQtTxs
          {tree}           : TXTree time block
            outputs totalFees qtTransactions
          rawBlock         : Block tree tree₂

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      isCoinbaseTree : ∀
        {block time outputs totalFees qtTransactions}
        (tree : TXTree time block outputs totalFees qtTransactions)
        → Dec (coinbaseTree tree)
      isCoinbaseTree genesisTree = no λ x → x
      isCoinbaseTree (txtree _ (normalTX _ _ _ _) _) = no λ x → x
      isCoinbaseTree (txtree _ (coinbase _ _ _) _) = yes tt

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      record fstTree
        {block : ℕ}
        {time₂ : Time}
        {outputs₂ : List TXFieldWithId}
        {totalFees₂ : Amount}
        {qtTransactions₂ : tQtTxs}
        (txTree₂ : TXTree time₂ block outputs₂
          totalFees₂ qtTransactions₂)
        : Set where
        constructor fstTreec

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        field
          {time}               : Time
          {outputs}            : List TXFieldWithId
          {totalFees}          : Amount
          {qtTransactions}     : tQtTxs
          {tree}               : TXTree time block
            outputs totalFees qtTransactions
          nxTree               : nextTXTree tree txTree₂
          fstBlockc            : firstTreesInBlock tree

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      record fstTree₂
        {block : ℕ}
        {time₂ : Time}
        {outputs₂ : List TXFieldWithId}
        {totalFees₂ : Amount}
        {qtTransactions₂ : tQtTxs}
        (txTree₂ : TXTree time₂ block outputs₂ totalFees₂
          qtTransactions₂)
        : Set where
        pattern
        constructor fstTreec₂

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        field
          {block₂}              : ℕ
          {time}               : Time
          {outputs}            : List TXFieldWithId
          {totalFees}          : Amount
          {qtTransactions}     : tQtTxs
          {tree}               : TXTree time block₂
            outputs totalFees qtTransactions
          eq                   : block ≡ block₂
          nxTree               : nextTXTree tree txTree₂
          fstBlockc            : firstTreesInBlock tree

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      fstTree₂→fstTree : ∀
        {block time₂ outputs₂ totalFees₂ qtTransactions₂}
        {txTree₂ : TXTree time₂ block outputs₂ totalFees₂
          qtTransactions₂}
        (fTree₂ : fstTree₂ txTree₂)
        → fstTree txTree₂
      fstTree₂→fstTree (fstTreec₂ refl nxTree fstBlockc)
        = fstTreec nxTree fstBlockc

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      record fstTreeChange
        (block : ℕ)
        (time : Time)
        (outputs : List TXFieldWithId)
        (totalFees : Amount)
        (qtTransactions : tQtTxs)
        : Set where
        constructor fstTreeChangedc
        field
          {tree}      : TXTree time block outputs
            totalFees qtTransactions
          ftree       : fstTree tree

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      changeBlockType : ∀
        {block block₂ time outputs totalFees qtTransactions}
        {tree : TXTree time block outputs totalFees qtTransactions}
        {txTree : TXTree time block outputs
          totalFees qtTransactions}
        (fstTree : fstTree tree)
        (eq : block ≡ block₂)
        → fstTreeChange block₂ time outputs
          totalFees qtTransactions
      changeBlockType fstTree refl = fstTreeChangedc fstTree

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      record TXChange
        {block : ℕ}
        {outSize : ℕ}
        {amount : ℕ}
        {time : Time}
        {block : ℕ}
        {outputs : List TXFieldWithId}
        {outputTX : VectorOutput time outSize amount}
        {totalFees : Amount}
        {qtTransactions : tQtTxs}
        (tree : TXTree time block outputs totalFees qtTransactions)
        (tx : TX tree outputTX)

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        (proofLess :
          toℕ qtTransactions ≤ totalQtSub1
          ⊎
          (isCoinbase tx))
        : Set where
        constructor TXChangedc
        field
          fTree                 : fstTree (txtree tree tx proofLess)

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}


      changeTXType : ∀
        {block time₁ time₂ totalFees₁ totalFees₂
          outputs₁ outputs₂ qtTransactions₁ qtTransactions₂
        outSize amount}
        {outputTX : VectorOutput time₂ outSize amount}
        {tree : TXTree time₁ block
          outputs₁ totalFees₁ qtTransactions₁}
        {tree₂ : TXTree time₂ block outputs₂
          totalFees₂ qtTransactions₂}
        (nxTree : nextTXTree tree tree₂)
        (fstBlockc : firstTreesInBlock tree)
        (tx : TX tree₂ outputTX)

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

        (proofLess :
          toℕ qtTransactions₂ ≤ totalQtSub1
          ⊎
          (isCoinbase tx))
        (eq : nextBlock tx ≡ block)
        → TXChange {block} tree₂ tx proofLess
      changeTXType nxTree fblock tx proof eq =
        let nxTX = nextTX nxTree tx proof
            ftree = fstTree₂→fstTree (fstTreec₂ eq nxTX fblock)
        in TXChangedc ftree

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}


      fstTreeBlock : ∀
        {block time outputs totalFees qtTransactions}
        {tree : TXTree time block outputs totalFees qtTransactions}
        (fstTree : fstTree tree)
        → ℕ
      fstTreeBlock {block} _ = block

      firstTree : ∀
        {block time outputs totalFees qtTransactions}
        (tree : TXTree time block outputs totalFees qtTransactions)
        → fstTree tree
      firstTree genesisTree = fstTreec (firstTX genesisTree) tt

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      firstTree {block₂} (txtree {block₁} tree tx proofLessQtTX)
        with isFirstTreeInBlock (txtree tree tx proofLessQtTX)
      ... | yes isFirst = fstTreec
        (firstTX (txtree tree tx proofLessQtTX)) isFirst
      ... | no ¬first with block₂ ≟ block₁
      ...   | yes eq = let ftree = firstTree tree
                           nxTree = fstTree.nxTree ftree
                           fstBlock = fstTree.fstBlockc ftree
                           chgType = changeTXType nxTree
                             fstBlock tx proofLessQtTX eq
                       in TXChange.fTree chgType
      ...   | no ¬eq = ⊥-elim impossible
                where postulate impossible : ⊥

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      txTree→Block : ∀
        {block time outputs totalFees qtTransactions}
        (tree : TXTree time block outputs totalFees qtTransactions)
        → Dec (RawBlock tree)
      txTree→Block genesisTree =
        no λ { (rawBlockc (blockc _ _ sndBlockCoinbase))
        → sndBlockCoinbase }

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      txTree→Block (txtree tree tx proofLessQtTX)
        with isCoinbaseTree (txtree tree tx proofLessQtTX)
      ... | no ¬isCoinbase =
              no λ{ (rawBlockc (blockc _ _ coinbaseTree))
                → ¬isCoinbase coinbaseTree}
      ... | yes isCoinbase = let fTree = firstTree
                                   (txtree tree tx proofLessQtTX)
                                 nxTree = fstTree.nxTree fTree
                                 fBlock = fstTree.fstBlockc fTree
                             in yes (rawBlockc
                               (blockc nxTree fBlock isCoinbase))

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      {-# TERMINATING #-}
      block→blockchain : ∀
        {block₁ time₁ outputs₁ totalFees₁ qtTransactions₁}
        {txTree₁ : TXTree time₁ block₁ outputs₁
          totalFees₁ qtTransactions₁}
        {time₂ outputs₂ totalFees₂ qtTransactions₂}
        {txTree₂ : TXTree time₂ block₁ outputs₂
          totalFees₂ qtTransactions₂}
        (block : Block txTree₁ txTree₂)
        → Blockchain block
      block→blockchain {_} {_} {_} {_} {_} {genesisTree}
        (blockc nxTree fstBlock₁ sndBlockCoinbase) =
        fstBlock' (blockc nxTree tt sndBlockCoinbase)

-- \end{code}
-- \end{frame}
-- \begin{frame}
-- \begin{code}

      block→blockchain {_} {_} {_} {_} {_} {txtree tree tx
        proofLessQtTX}
        (blockc nxTree fstBlock₁ sndBlockCoinbase)
        with firstTree tree
      ... | fstTreec nxTree₁ fstBlockc = addBlock
        (block→blockchain (blockc nxTree₁ fstBlockc
          (fstTree→coinbase fstBlock₁)))
        (blockc nxTree fstBlock₁ sndBlockCoinbase)
\end{code}
}
% \end{frame}

\begin{frame}
   \frametitle{Mining}
   \begin{itemize}
     \item Every block has a cryptographic problem to be solved. That is,
       you need to calculate a nounce value such that the block hash
       is less than a specified value.
     \item This specified value is calculated from the average of the last 2016 blocks (2 weeks)
       so that the average block mining is 10 minutes.
   \end{itemize}
\end{frame}

\begin{frame}{Conclusions}
  \begin{itemize}
    \item In this work, all specifications were placed on types.
    \item In other works, the approach may be different.
      That is, without any information on types and all proofs done separately.
    \item This approach was not chosen as it is much simpler to understand the code
      when types are more expressive.
  \end{itemize}
\end{frame}

\begin{frame}{Missing Details}
  \begin{itemize}
    \item Calculate block hash and block nounce field.
    \item Change protocol to receive entire block instead of individual transactions.
    \item Add if there is a blockchain larger than the server's size.
  \end{itemize}
\end{frame}

\begin{frame}{More complex parts to add}
  \begin{itemize}
    \item Formal modeling of the blockchain as a distributed system.
    \item Create client code to interact with nodes.
    \item Specify the protocol between client and node and between node to node.
      However, the hardest part has already been coded, which is adding the evidence
      to the raw data that the client sends.
    \item Add a scripting language to the cryptocurrency.
  \end{itemize}
\end{frame}

\section{Bibliography}

\begin{frame}{Bibliographic references}
  \bibliographystyle{apacite}
  \bibliography{References}
\end{frame}

\end{document}
